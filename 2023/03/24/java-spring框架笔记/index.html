<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>java-spring框架笔记 | Ly's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java-spring框架笔记</h1><a id="logo" href="/.">Ly's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">java-spring框架笔记</h1><div class="post-meta">2023-03-24<span> | </span><span class="category"><a href="/categories/java/">java</a></span></div><div class="post-content"><p>今天起开始java-spring框架的学习，在此以笔记的形式记录下学习过程，由于是从0开始的学习笔记，理解有错误的地方欢迎各位及时指正。</p>
<h3 id="Spring框架简介"><a href="#Spring框架简介" class="headerlink" title="Spring框架简介"></a>Spring框架简介</h3><p>Spring是一个轻量级java开发框架，使用Spring框架的目的是为了为了减少开发过程中的重复工作，以及增强规范性，降低耦合性，其核心是控制反转（IOC）和面向切面（AOP）</p>
<h3 id="Spring框架入门"><a href="#Spring框架入门" class="headerlink" title="Spring框架入门"></a>Spring框架入门</h3><h4 id="1、部署使用框架"><a href="#1、部署使用框架" class="headerlink" title="1、部署使用框架"></a>1、部署使用框架</h4><p>由于要使用maven来进行spring框架的开发，我们先配置好maven环境 在file-setting-Build…-Build Tools-Maven处配置maven环境路径，这里我使用了3.8.3版本的maven，这里需要注意的是java版本是否支持 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage1.png"> 待maven环境配置完成后，新建一个maven项目 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage2.png"> 创建完成后打开pom.xml，配置springframework，在这里添加几行代码更新maven即可 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage3.png"> 等待加载完成就配置好了</p>
<h4 id="2、第一个spring程序"><a href="#2、第一个spring程序" class="headerlink" title="2、第一个spring程序"></a>2、第一个spring程序</h4><p>首先我们在com.itheima下创建一个HelloSpring类，包含一个set、方法和一个show方法 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage4.png"> 然后我们再applicationContext.xml里给username赋值 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage5.png"> 最后我们创建一个test类，来调用helloSpring的show方法，运行测试。 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage6.png"> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage7.png"></p>
<h4 id="何为控制反转-何为依赖注入"><a href="#何为控制反转-何为依赖注入" class="headerlink" title="何为控制反转?何为依赖注入?"></a>何为控制反转?何为依赖注入?</h4><p>相信大家看完概念并做完第一个案例后依然无法准确的描述出到底什么是控制反转和依赖注入，那么我们可以先看一下上面的案例在没有使用框架技术的情况下该如何调用show方法: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage8.png"> 很明显在这个test类中我们直接通过代码实例化出了HelloSpring类，然后调用set方法赋值，并调用show方法，这是最常见的写法。而在使用spring框架时我们是通过xml文件的标签给HelloSpring类的属性进行赋值的，通过xml文件进行赋值的过程就叫做依赖注入，依赖谁注入谁呢?某个类依赖IoC&#x2F;DI容器对要实例化的外部资源类进行注入。这便是依赖注入的概念。 至于控制反转描述的同样是这个过程，只不过角度不同。在我们不用spring框架时，要调用某个外部资源类时都要自己去实例化并赋值，而控制反转描述的是在我们使用spring框架时，对外部资源的实例化和赋值都由IoC&#x2F;DI容器进行控制，这些过程我们只需要对容器进行操作就可以实现，控制关系从程序控制转变为容器控制，这便是控制反转。</p>
<h3 id="标签的作用及属性详解"><a href="#标签的作用及属性详解" class="headerlink" title="标签的作用及属性详解"></a>标签的作用及属性详解</h3><h4 id="1、常见标签"><a href="#1、常见标签" class="headerlink" title="1、常见标签"></a>1、常见标签</h4><p><strong>bean：</strong> 作用: 配置javaBean,让spring容器创建管理.默认调用类中无参数的构造方法创建对象 属性: id:唯一标识 class：类的全限定名称 scope：设置bean的作用范围，如sigleton单例或prototype多例 factory-method：指定实例工厂方法 factory-bean：指定实例工厂对象 <strong>constructor-arg：</strong> 作用:通过构造方法给成员变量赋值 属性: index:索引 name:指定成员变量在构造方法参数列表中的名称 type:指定类型 value:赋值 ref:给其他bean类型成员变量赋值 <strong>property：</strong> 作用:通过set方法给成员变量赋值 name：指定成员变量的名称 value:赋值 ref:给其他bean类型成员变量赋值 <strong>aop:config：</strong> 作用: 声明aop配置 <strong>aop:aspect：</strong> 作用: 配置切面</p>
<h4 id="2、constructor-arg标签-的应用："><a href="#2、constructor-arg标签-的应用：" class="headerlink" title="2、constructor-arg标签****的应用："></a><strong>2、constructor-arg标签****的应用：</strong></h4><p>constructor-arg标签是基于构造方法实现的 首先创建一个User1类实现构造方法和toString方法 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage9.png"> 在applicationContext.xml里配置constructor-arg标签交给spring容器创建实例并赋值，这里的配置可以有三种方式，分别是使用name属性、type属性、index属性，但index属性要注意顺序，type属性需要留意多个参数相同的情况 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage10.png"> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage11.png"> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage12.png"> 创建test类进行测试 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage13.png"> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage14.png"></p>
<h4 id="3、property标签的应用"><a href="#3、property标签的应用" class="headerlink" title="3、property标签的应用"></a><strong>3、property标签的应用</strong></h4><p>property标签是基于set方法实现 同样创建一个user2类，实现set方法和toString方法 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage15.png"> 同样在xml里配置property标签，这里也有两种方式，第一种是在property配合name、value属性进行注入，第二种是使用ref，对另一个bean对象赋值，但这里会输出整的user1的对象而不会单独对每个属性赋值 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage16.png"> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage17.png"> 创建test类 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage18.png"> 比较两次运行结果体会差异: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage19.png"> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage20.png"></p>
<h3 id="Bean的三种实例化方式"><a href="#Bean的三种实例化方式" class="headerlink" title="Bean的三种实例化方式"></a>Bean的三种实例化方式</h3><blockquote>
<p>1、使用类构造器实例化（构造函数）：直接通过Spring工厂返回类的实例对象。首先在类里写一个构造方法，在applicationContext.xml里进行赋值，通过测试类创建xml实例后getBean调用该类的方法。 2、使用静态工厂方法实例化（简单工厂模式）：Spring工厂调用自定义工厂的静态方法返回类的实例对象。创建一个静态工厂方法，返回要调用的类，从xml里通过class和factory-method赋值，最后同样在test类里getbean调用该类的方法 3、使用实例工厂方法实例化（工厂方法模式）：Spring工厂调用工厂的普通方法（非静态方法）返回类的实例对象。创建一个普通工厂方法，返回要调用的类，从xml里要写两个bean，其中一个<bean>标签用来定义工厂类本身，利用容器去实例化方法，另一个<bean>标签用来指定要调用的工厂方法和返回的bean类型，最后同样在test里getbean调用该类的方法</p>
</blockquote>
<p><strong>三种方式实例对比:</strong></p>
<h4 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h4><p>创建一个简单的Bean1类 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage21.png"> 在xml里创建bean标签 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage22.png"> test实现 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage23.png"></p>
<h4 id="2、静态工厂实例化"><a href="#2、静态工厂实例化" class="headerlink" title="2、静态工厂实例化"></a>2、静态工厂实例化</h4><p>同样创建一个简单的Bean2类 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage24.png"> 创建静态工厂方法 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage25.png"> 在xml实现静态工厂 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage26.png"> 创建test类测试 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage27.png"></p>
<h4 id="3、实例化工厂"><a href="#3、实例化工厂" class="headerlink" title="3、实例化工厂:"></a>3、实例化工厂:</h4><p>创建Bean3类 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage28.png"> 在xml实现实例化工厂方法 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage29.png"> 写test类测试: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage30.png"></p>
<h4 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结:"></a>4、总结:</h4><p>这三种方式的区别主要在于实例化Bean的方式不同。使用类构造器实例化是最简单的方式，只需要在配置文件中指定Bean的类名即可。使用静态工厂方法实例化和使用实例工厂方法实例化则需要在配置文件中指定工厂类和工厂方法。 这三种方式都可以用来实例化Bean，但是它们各自适用于不同的场景，下面两种开发的自由度更高。 <strong>为什么实例工厂方法实例化需要两个bean标签？</strong> 因为一个<bean>标签用来定义工厂类本身，利用容器去实例化方法，另一个<bean>标签用来指定要调用的工厂方法和返回的bean类型。例如在刚才的案例里：第一个<bean>标签定义了一个id为Person3Factory的工厂类，第二个<bean>标签指定了要调用工厂方法的create方法来创建实例，并将其id设为person3，而静态方法调用可以不加类名 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage31.png"></p>
<h3 id="基于注解的装配"><a href="#基于注解的装配" class="headerlink" title="基于注解的装配"></a>基于注解的装配</h3><blockquote>
<p>注解是以‘@注解名’在代码中存在的，根据注解参数的个数，我们可以将注解分为：标记注解、单值注解、完整注解三类。和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</p>
</blockquote>
<h4 id="常用的注解功能介绍："><a href="#常用的注解功能介绍：" class="headerlink" title="常用的注解功能介绍："></a><strong>常用的注解功能介绍：</strong></h4><p><strong>1、创建对象的注解</strong> @Component:可以创建任意对象 @Controller:专门用来创建控制器的对象(Servlet),这种对象可以接收用户的请求,可以返回处理结果给客户端. @Service:专门用来创建业务逻辑层的对象,负责向下访问数据访问层,处理完毕后的结果返回给界面层. @Repository:专门用来创建数据访问层的对象,负责数据库中的增删改查所有操作. <strong>2、依赖注入的注解</strong> @Value:用来给简单类型注入值 @Autowired:使用类型注入值,从整个Bean工厂中搜索同源类型的对象进行注入. @Resource注解:使用name属性注入 <strong>3、Java自带的标准注解</strong> @Override注解是用来指定方法重写的，只能修饰方法并且只能用于方法重写，不能修饰其它的元素。 @Deprecated可以用来注解类、接口、成员方法和成员变量等，用于表示某个元素（类、方法等）已过时。 @SuppressWarnings是用来抑制编译器警告 <strong>4、元注解</strong> @Retention是用于说明注释的生命周期，即说明的注释在哪个范围内有效 @Target是用来表示注解作用范围，超过这个作用范围，编译的时候就会报错。 @Inherited是标记表明某个标记的类型被继承， @Documented是用来标注生成javadoc的时候是否会被记录 <strong>5、自定义注解</strong> 可以根据自己的需求定义注解 例如@interface <strong>案例：</strong> 1、首先告诉spring使用注解开发 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage32.png"> 2、对Product属性进行赋值，使用content创建出三层对象，设置singleton单例 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage33.png"> 3、使用@Repository创建UserDao <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage34.png"> 4、使用@Service创建Productservice对UserDao(唯一标识)注入值 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage35.png"> 5、使用@Controller找到UserController，把刚刚创建的productService注入过来 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage36.png"> 6、运行测试类 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage37.png"></p>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h4 id="1、AOP中的一些基本概念："><a href="#1、AOP中的一些基本概念：" class="headerlink" title="1、AOP中的一些基本概念："></a><strong>1、AOP中的一些基本概念：</strong></h4><p><strong>通知&#x2F;增强处理:</strong> 简单来说就是想要的功能，包含Aspect的一段代码处理 <strong>连接点:</strong> 任何允许通知的方法前后或者抛出异常时都可以是连接点，spring只支持方法连接点。 <strong>切入点:</strong> 切入点必是连接点，想要切入方法实现的连接点就是切入点 <strong>切面:</strong> 切入点和通知的结合 <strong>切入表达式:</strong></p>
<blockquote>
<p>首先要创建业务类，提前确认切入点，编写切入类，切入类需要在方法上方添加@before或@after来实现切面功能，切面表达式格式为@(切入位置) (value &#x3D; “execution(权限 返回类型 切入位置)”)，权限处可以留空，返回类型部分若无指定返回类型可以指定*，代表任意类型返回值。切入位置处通常是如下格式:com.xxxx.*.*(…)等格式，*在包路径后代表该包下的任意文件，在()前代表任意函数名，..在括号内代表任意返回值类型，了解切入点表达式是学习AOP最重要的一环。</p>
</blockquote>
<h4 id="2、AOP的两种实现方式"><a href="#2、AOP的两种实现方式" class="headerlink" title="2、AOP的两种实现方式:"></a>2、AOP的两种实现方式:</h4><p><strong>XML方式</strong></p>
<blockquote>
<p>我们创建xml文件添加需要的bean标签，其包括实现类和唯一标识符。AOP的实现需要额外添加一条<a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a></aop:aspectj-autoproxy>用于绑定，作用是自动代理。若需要子类实现可以添加&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;”true”&gt;</aop:aspectj-autoproxy>设置为子类代理，最后创建Test类测试即可</p>
</blockquote>
<p><strong>注解方式</strong></p>
<blockquote>
<p>在XML的实现基础上，注解方式并不需要改变太多。首先需要在业务类添加@Component注解用于实现该类，然后在切面类添加@Aspect注解，交给AspectJ的框架去识别切面类，且切面类本身也需要@Component去实现。到此，applicationContext的bean标签就可以删除了，取而代之的是注解实现必备的包扫描: &lt;context:component-scan base-package&#x3D;”com.bjpowernode.s01”&gt;</context:component-scan>，其余的均不需要改动</p>
</blockquote>
<p><strong>实例:</strong> <strong>XML方式:</strong> 首先我们通过XML方式实现AOP，创建一个基本的计算器业务 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage38.png"> 写入我们的切入类,包括前置方法和后置方法: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage39.png"> 在XML里实现业务方法和切面方法，并绑定aop自动代理，这里的aop标签是必备的: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage40.png"> 创建test类进行测试: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage41.png"> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage42.png"> <strong>注解方式：</strong> 这里基于XML方式修改 将业务类使用@component标签交给spring容器创建 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage43.png"> 切面类同样使用@component标签创建，同时还需要@Aspect 标签交给AspectJ的框架去识别切面类,添加before和after切入 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage44.png"> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E8%A1%A5%E5%85%851.png"> XML里需要添加两条，首先注解需要包扫描，同时还需要aop的自动代理标签 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage45.png"> 到此就修改完成了 调用Test类测试:效果相同 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage46.png"> 这里涉及到一个proxy-target-class&#x3D;”true”的作用，恰好老师上课问到了，这里就详细使用下面的案例来解释一下 这是一个基本的aop项目，项目存在impl接口的实现类，这里我们把本应该是someService的类型改成他的子类someServiceImpl类型： <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage47.png"> 此时运行会报错 这个时候把<code>&lt;aop:aspectj-autoproxy &gt;&lt;/aop:aspectj-autoproxy&gt;</code>改成<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;&lt;/aop:aspectj-autoproxy&gt;</code>，再重新运行一下，发现成功了 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage48.png"><img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage49.png"> <strong>这个原理是什么呢?</strong> <em>在 Spring AOP 中，代理是用来在目标对象和调用者之间添加额外的行为（例如日志记录、安全检查等）。Spring AOP 可以使用两种不同的代理机制：JDK 动态代理和 CGLIB。</em> <em>JDK 动态代理是通过实现目标对象的接口来创建代理。这意味着，如果您的目标对象实现了至少一个接口，那么 Spring AOP 将使用 JDK 动态代理来创建代理。但是，如果您的目标对象没有实现任何接口，那么 Spring AOP 将无法使用 JDK 动态代理。</em> <em>在这种情况下，Spring AOP 将使用 CGLIB 来创建代理。CGLIB 是一个第三方库，它可以在运行时动态生成目标对象的子类，并将额外的行为添加到子类中。这样，即使您的目标对象没有实现任何接口，Spring AOP 也可以使用 CGLIB 来创建代理。</em> <em>当在 <code>&lt;aop:aspectj-autoproxy&gt;</code>中设置<code>proxy-target-class=&quot;true&quot;</code>时，强制 Spring AOP 使用 CGLIB 来创建代理，而不是 JDK 动态代理。这样即使目标对象实现了至少一个接口，Spring AOP 也将使用 CGLIB 来创建代理。</em></p>
<h3 id="数据库开发"><a href="#数据库开发" class="headerlink" title="数据库开发"></a>数据库开发</h3><p>一般搭建网站的过程都会有与数据库的交互，这个章节我们学习数据库开发，采用mysql数据库和spring对接开发。</p>
<h4 id="1、前期准备"><a href="#1、前期准备" class="headerlink" title="1、前期准备:"></a><strong>1、前期准备</strong><strong>:</strong></h4><p>首先要配置好数据库环境，开启mysql数据库服务，创建相关数据库，这里我使用课上的案例直接导入数据库 在导入时发现了一个报错： <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage50.png"> 报错原因似乎是由于这个语句与我的版本不匹配，打开sql文件查看一下，报错位置在第一句: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage51.png"> 这句话是用来检测如果存在这个数据库就将它删除掉的，所以既然报错我们删除这句也无伤大雅，删除后重新导入成功: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage52.png"> 配置好数据库我们还要在pom中导入相关依赖: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage53.png"> application.xml配置，重点在于账号密码要与数据库一致: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage54.png"> 到此，前期准备结束</p>
<h4 id="2、项目案例"><a href="#2、项目案例" class="headerlink" title="2、项目案例:"></a><strong>2、项目案例:</strong></h4><p>下面我们还是用一个学生信息的增删改查案例来了解spring如何进行数据库开发 首先创建一个student类，包含id、姓名、性别、生辰，并实现get、set方法 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage55.png"> 写一个dao方法类，定义对数据库进行增删改查的基础方法 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage56.png"> 在Impl里实现接口，我们先重点关注add方法 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage57.png"> 从这个示例中我们可以看出sql执行的基本流程:</p>
<blockquote>
<p>1、定义一个JdbcTemplate对象，并提供getJdbcTemplate()和setJdbcTemplate()方法来设置和获取JdbcTemplate对象。 2、编写add方法，定义sql语句，获取传入的student类中各个参数传入到定义的Object类型数组中 3、使用JdbcTemplate的update方法将数组中的值填充到sql语句中执行</p>
</blockquote>
<p>那接下来我们编写一个测试类来添加一条数据 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage58.png"> 运行后显示添加成功，可以在数据库中找到id&#x3D;2的数据 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage59.png"><img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage60.png"> 其他的几个功能也是类似，只是sql语句不同 删除功能: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage61.png"> 更改功能: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage62.png"> 通过id查询功能: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage63.png"></p>
<h4 id="3、其他问题："><a href="#3、其他问题：" class="headerlink" title="3、其他问题："></a><strong>3、其他问题：</strong></h4><p>编写的测试类也都大同小异，这里就不做具体演示了，下面说个容易出问题的点。 大多数我们使用数据库的时候都会出现要向数据库插入日期类型的情况，这里存在两个包 <code>import java.util.Date;</code> <code>import java.sql.Date;</code> 导入的时候可能会混淆，但其实这两个都可以用，java.util.Date是java.sql.Date的父类，以2020-03-10为例，在使用java.util.Date的是时候我们需要使用 SimpleDateFormat 类的 parse 方法将字符串 “2020-03-10” 转换为日期类型，然后使用 student 对象的 setBorn 方法将转换后的日期设置为学生的出生日期 <code>student.setBorn(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;2020-03-10&quot;));</code> 而java.sql.Date只需直接输入日期即可 <code>student.setBorn(Date.valueOf(&quot;2005-12-12&quot;));</code> 这两者效果是一样的，但不管使用哪种方法最终set的数据类型必须要和定义Student类的生日属性使用的包相同，个人建议如果没有特殊格式要求统一使用java.sql.Date会比较方便 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage64.png"></p>
<h4 id="4-、事务操作"><a href="#4-、事务操作" class="headerlink" title="4**、事务操作:**"></a><strong>4**<strong>、事务操作</strong></strong>:**</h4><p>很多情况下我们需要实现诸如转账之类的服务器与客户端或另一个客户端同步记录的功能，如果在一方操作完被报错中断没来得及对另一方进行操作就会出现数据操作，这个时候就需要用到事务操作，恰似”同进退，共生死”。 我们先通过XML方式实现一个删除与插入绑定的项目，体会事务的作用: 首先创建一个Student类实现getter、setter等方法 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image65.png"> 在接口类里定义一个事务方法 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image66.png"> 在接口实现类里重写出transfer方法，实现一个删除和插入方法 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image67.png"> 在xml里配置jdbc以及把studentDao交给spring容器创建 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image68.png"> 此时我们在数据表插入一条数据: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image69.png"> 编写一个Test类，实现删除该条数据并插入一条新的数据 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image70.png"> 我们运行一下发现数据表中数据已经按照预想的结果更改了 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image71.png"> 这时我们重新插入name为zhangsan的数据，然后为了模拟一下在删除和重新插入之间出现报错的情况，在他们之间插入一条int i&#x3D;1&#x2F;0来模拟异常 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image72.png"> 此时我们再去运行test类，这里出现了报错 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image73.png"> 再看一下数据表的情况，可以看到删除操作执行了但插入操作并没有执行 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image74.png"> 那么如何避免这种情况呢？这里就用到了事务 我们在xml文件里配置事务 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image75.png"> 这里的配置不认识的参数很多，我们详细解释一下:</p>
<blockquote>
<p>首先，定义了一个名为transactionManager的bean，它的类是org.springframework.jdbc.datasource.DataSourceTransactionManager。这个bean有一个名为dataSource的属性，它引用了另一个名为dataSource的bean，也就是我们定义的数据源。 然后，定义了一个名为txAdvice的事务建议，它使用了上面定义的transactionManager作为事务管理器。在这个建议中，定义了一个名为tx:attributes的元素，用于指定事务属性。在这个元素中，定义了一个名为tx:method的元素，用于指定方法级别的事务属性。这里指定了所有方法（name&#x3D;“*”）都需要事务支持（propagation&#x3D;“REQUIRED”），且不是只读事务（read-only&#x3D;“false”），隔离级别为默认（isolation&#x3D;“DEFAULT”），超时时间为-1（timeout&#x3D;“-1”）。 最后，定义了一个名为aop:config的元素，用于配置AOP。在这个元素中，定义了一个名为aop:pointcut的元素，用于指定切入点表达式。这里指定了切入点表达式为execution(* cn.hdc.StudentDao.*(..))，表示匹配cn.hdc.StudentDao类中的所有方法。然后，定义了一个名为aop:advisor的元素，用于指定通知器。这个通知器引用了上面定义的txAdvice作为通知，并使用上面定义的切入点。</p>
</blockquote>
<p>简而言之，这段代码配置了一个事务管理器，并使用AOP来将事务应用到cn.hdc.StudentDao类中的所有方法。   配置好事务我们重新插入名为ZhangSan的数据，再次运行test类，结果由于我们的模拟异常操作出现报错，这时我们再看数据库，发现数据没有被删除 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image76.png"> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image77.png"> 通过这个案例我们了解了事务的用途，下面介绍使用注解的事务操作 再接口实现类中插入一行 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image78.png"></p>
<blockquote>
<p>propagation &#x3D; Propagation.REQUIRED表示这个方法需要事务支持，如果当前没有事务，就新建一个事务；如果当前已经有事务，就加入到当前事务中。 isolation &#x3D; Isolation.DEFAULT表示使用默认的隔离级别。隔离级别用于控制多个事务之间的可见性，以防止脏读、不可重复读和幻读等问题。 readOnly &#x3D; false表示这个事务不是只读的。只读事务通常用于查询操作，可以提高性能。</p>
</blockquote>
<p>这句话声明了一个方法需要事务支持，使用默认的隔离级别，并且不是只读的。 然后我们在xml配置文件里添加一行配置，用于开启注解式声明事务 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image79.png"> 这样实现事务的效果和xml方式是相同的，运行test后同样因为异常报错，但数据库中数据回滚不变。 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image80.png"> 实现过程中遇到的问题: 在实现项目时，多次检查代码配置无误后发现事务依然不生效，再寻求老师的帮助后我了解到问题出现在储存引擎 这里是我创建数据库的语句: <code>CREATE TABLE stu (</code> <code>    sid INT PRIMARY KEY AUTO_INCREMENT,</code> <code>    sname VARCHAR(20),</code> <code>    age VARCHAR(20),</code> <code>    course VARCHAR(20)</code> <code>);</code> 这个是老师创建数据库使用的语句: <code>CREATE TABLE `stu` (</code> <code>  `sid` int(5) NOT NULL AUTO_INCREMENT COMMENT &#39;学生编号&#39;,</code> <code>  `sname` varchar(20) DEFAULT NULL,</code> <code>  `age` varchar(20) DEFAULT NULL,</code> <code>  `course` varchar(20) DEFAULT NULL,</code> <code>  PRIMARY KEY (`sid`)</code> <code>) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;</code>   主要区别在于老师给出的语句指定了储存引擎为InnoDB，而我使用的创建语句默认为MyISAM引擎，是不支持事务操作的，所以这里在使用事务时也要格外注意 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage81.png"></p>
<h3 id="Mybatis框架"><a href="#Mybatis框架" class="headerlink" title="Mybatis框架"></a>Mybatis框架</h3><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。 它能把数据保存在数据库中，也能从数据库中读取数据，使用了Mybatis可以减少代码的重复，提高了开发效率。 下面我们通过一个Mybatis项目实例来了解该框架的配置使用以及优点 数据库中有一个学生数据表，具体结构如下: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage82.png"> 要求使用Mybatis框架完成增删改查的操作 首先我们在<code>pom.xml</code>里引入Mybatis需要的环境，这几项是必须的： <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage83.png"> 然后根据数据库配置jdbc <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage84.png"> 创建一个学生类，实现有参和无参构造方法，创建getter，setter方法: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage85.png"> 我把重心放在mybatis配置文件的理解，首先看第一个配置文件：<code>mybatis-config.xml</code> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage86.png"></p>
<blockquote>
<p>这里的<typeAliases>标签，类型别名是为 Java 类型设置一个短的名称。它只用于 XML 配置，可以简化我们的书写。在这个例子中，<package name="cn.hdc.ch5.pojo"></package> 指定了一个包名，MyBatis 会在包 cn.hdc.ch5.pojo 中搜索需要自动为其创建别名的 Java Bean，别名默认为类名，也就是说如果我们cn.hdc.ch5.pojo下存在一个student类，我们只需直接使用student即可，而不再需要cn.hdc.ch5.pojo.student <environments default="development">在这个标签中MyBatis 可以配置多种<environment>环境，这样就可以在同一配置文件中切换不同的数据库。default 属性指定了默认环境。在这个例子中，默认使用为 development 的环境。 下面的transactionManager配置了事务管理器的类型为JDBC，类型为POOLED连接池，下面引入了我们数据库中的配置 最关键的是这里的mappers，<mappers>映射器是 Java 方法与 SQL 语句的桥梁。在这个例子中，配置了一个映射器文件 cn.hdc.ch5.mapper&#x2F;StudentMapper.xml。</p>
</blockquote>
<p>下一个要配置的文件是Mapper的xml文件： <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage87.png"></p>
<blockquote>
<p>开头<mapper>标签中的namespace定义了命名空间，下面通过在<select>、<insert>、<update>、<delete>等标签里定义语句传参实现与数据库交互，在 resultMap 中，可以使用 <id> 和 <result> 元素来定义列名和对象属性之间的映射关系。在这个例子中，定义了四个映射关系：列 studentMap 映射到属性 sid，列 sname 映射到属性 sname，列 sage 映射到属性 age，列 course 映射到属性 course。然后通过<select>标签指定resultMap 属性来引用定义好的 resultMap。另外各个标签里的resultType&#x3D;”student”也体现了上面配置文件中起别名的便捷。</p>
</blockquote>
<p>主要的配置文件写完了，通常还需要编写个工具类 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage88.png"></p>
<blockquote>
<p>在这个工具类中，首先定义了一个salSessionFactory类型的静态变量sqlSessionFactory，SqlSessionFactory 是 MyBatis 的另一个核心接口，它用于创建 SqlSession 对象。 在下面的静态代码块中，使用 Resources.getResourceAsReader 方法读取 MyBatis 配置文件 mybatis-config.xml，然后使用 SqlSessionFactoryBuilder.build 方法根据配置文件创建 SqlSessionFactory 对象。最后在静态方法 getSqlsession 中，调用 sqlSessionFactory.openSession 方法来返回一个新的 SqlSession 对象。</p>
</blockquote>
<p>到此所有关键部分都编写完成，创建test类进行测试。 test类代码千篇一律不做过多叙述: 增: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage89.png"> 删: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage90.png"> 改： <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage91.png"> 通过id查询： <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage92.png"> 查询表中全部内容: <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fimage93.png"></p>
<h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p>之前学的mybatis框架相关内容都是实现简单的增删改查，但在实际的业务需求中并非只有增删改查那么简单，例如：获取业绩排行前十的人员姓名、展示年龄小于30岁的人员工号等等。 <strong>常用标签</strong></p>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>if标签通常用于where语句后的判定，根据if语句的判定条件生成不同的sql语句，如下面这个案例中，如果username不为空，则拼接语句为select * from t_customer where 1&#x3D;1 and username&#x3D;(传入的参数) 若username为空，但job不为空则拼接后的语句为select * from t_customer where 1&#x3D;1 and jobs&#x3D;(传入的参数) <a target="_blank" rel="noopener" href="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image94.png">https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image94.png</a></p>
<h4 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h4><p>观察下面这个案例，这三者配合起来和if其实差不多，但是逻辑变成了如果传入username就按username拼接，如果传入了jobs就用jobspinjie，如果二者都没有传入就按otherwise中的phone参数去拼接 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image95.png"></p>
<h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p>在上面使用where语句时由于拼接语句时开头为and所以要拼接一个1&#x3D;1恒真的条件，很容易忘掉导致错误，其实这里可以使用<where>标签来替换，效果和手写where语句相同 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image96.png"></p>
<h4 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h4><p>trim通常用来增删字符，下面这个例子里，使用prefix添加了一个where，用prefixOverrides删除语句中的and 而set标签就相当于sql语句中的set，通常与update联用，用于更新数据 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image97.png"> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image98.png"></p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>很多时候我们查询的数据需要循环遍历，尤其是构建in语句时，在<foreach>标签中open代表数据开头添加的符号，close代表结尾的闭合，separator代表数据分割的符号，例如下面这个案例，对id进行遍历，编写test类将数组通过遍历拼接到in语句后 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image99.png"> <strong>test类</strong> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image100.png"> 也可以引入map来遍历 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image101.png"> <strong>test类</strong> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image102.png"></p>
<h4 id="遇到的相关问题"><a href="#遇到的相关问题" class="headerlink" title="遇到的相关问题:"></a>遇到的相关问题:</h4><p><strong>关于xml配置文件位置的问题</strong> 在本次测试项目中Customer的xml配置文件没有放在resources目录下，这会导致有些时候出现无法找到xml文件的错误 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image103.png"> <strong>解决办法：</strong> 1、在pom.xml添加一段扫描配置，让其自动检索 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image104.png"> 2、在资源目录下创建相同结构的xml文件</p>
<h3 id="Mybatis关联映射"><a href="#Mybatis关联映射" class="headerlink" title="Mybatis关联映射"></a>Mybatis关联映射</h3><p>由于上节课缺席导致这一章节学的有些懵，抽出时间特地学习整理了下。</p>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>下面这个数据表中class和student是一对多的关系，一个班级可以有多个学生，但一个学生只对应一个班级 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image105.png"> <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image106.png"> 那么我们如何在java代码中体现出这种关系呢 基础配置到这个章节了就不详细说了，先看基础类 student我们使用StuIfo实体类表示 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image107.png"> class使用StuClass实体类表示，由于是一对多，这里的学生使用list形式定义 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image108.png"> 重点在于下面的配置文件，先看student的配置文件 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image109.png"> <select>标签查询两个表sid和cid相同的数据关联起来，使用resultmap结果集去映射。resultmap结果集定义为StuInfo类型，除id外，包含sname、age、course、classid、stuClass五个结果的映射，其中stuClass使用association标签进行一对一关系的映射。 之前一直对映射这个名词理解不深刻，既然学习了就详细记录下，就我个人理解，resultmap更像是实例化了一个StuInfo对象，把select查询到的数据一一填充进去，property对应对象的字段名，column对应数据表的字段名，而这里的asscoiation就像是在StuInfo对象里又实例化了一个StuClass类。 再看class的配置文件： <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image110.png"> 和student配置文件唯一不同的是这里的StuInfo使用的是<collection>标签，这个标签代表的是一对多的映射关系，而StuInfo也是list类型，也就是说这个配置文件里一个结果集里面会存在多个StuInfo属性以list形式显示。 最后我们创建一个test类测试一下</p>
<h5 id="findclass测试"><a href="#findclass测试" class="headerlink" title="findclass测试"></a>findclass测试</h5><p>这里并没有映射StuInfo的stuClass属性，所以显示为空，如果映射的话就变成套娃了。可以看到一个班级中有多个学生的一对多关系成功表示了出来 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image111.png"></p>
<h5 id="findStu测试"><a href="#findStu测试" class="headerlink" title="findStu测试"></a>findStu测试</h5><p>这里一个学生对应一个班级的关系也成功表达出来。 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image112.png"></p>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>这时我们再引入一个教师角色，一个教师可以教多个班级，而一个班级又有多个老师，这样老师和班级之间就是多对多的关系</p>
<h5 id="教师类"><a href="#教师类" class="headerlink" title="教师类"></a>教师类</h5><p><img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image113.png"></p>
<h5 id="班级信息类"><a href="#班级信息类" class="headerlink" title="班级信息类"></a>班级信息类</h5><p><img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image114.png"> 在配置xml文件时，TeachInfo中的classes属性和ClassInfo中的teaches属性都要使用collection标签进行处理，其他配置基本相同 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image115.png"> 相对于一对多来说，多对多的映射关系原理大体上相同，但在实际编写过程中却出了很多问题，大多数问题是出在在数据表和sql语句上 实现这个多对多的过程中有三张表，一张教师信息表teach_info、一张班级信息表class_info、一张教师和班级对应关系表class_teach 最值得注意的是这张class_teach表 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image116.png"> 在编写sql语句时要依照class_id和teach_id的对应关系，语句编写如下:</p>
<blockquote>
<p>SELECT c.*,t.* from teach_info t,class_info c,class_teach ct where c.cid &#x3D; ct.class_id and ct.teach_id &#x3D; t.tid and c.cid&#x3D; #{cid}</p>
</blockquote>
<p>同时select出信息也要包含所有resultmap映射的数据 例如我的sql语句如果这样写，故意缺省了t.tid：</p>
<blockquote>
<p>SELECT c.*,t.tname,t.age,t.course from teach_info t,class_info c,class_teach ct where c.cid &#x3D; ct.class_id and ct.teach_id &#x3D; t.tid and c.cid&#x3D; #{cid}</p>
</blockquote>
<p>此时的运行结果tid就是null <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image117.png"> 修改成正确的语句，运行成功 <img src="https://lyblog-1309143339.cos.ap-beijing.myqcloud.com/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image118.png"></p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul></div><div class="post-nav"><a class="pre" href="/2023/03/28/wp-global-styles-lolimeow/">Custom Styles</a><a class="next" href="/2023/03/10/cscg2023-earth-wp/">CSCG2023-earth WP</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/toy/">toy</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/uncategorized/">uncategorized</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web%E5%AE%89%E5%85%A8/">web安全</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/toy/" style="font-size: 15px;">toy</a> <a href="/tags/ctf/" style="font-size: 15px;">ctf</a> <a href="/tags/web%E5%AE%89%E5%85%A8/" style="font-size: 15px;">web安全</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/python/" style="font-size: 15px;">python</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/10/18/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/02/28/%E8%AE%B0%E4%B8%80%E6%AC%A1sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%AE%9E%E6%88%98/">记一次sql注入绕过实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/13/510/">记一次娱乐测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/18/vulnhub-dc3%E9%9D%B6%E5%9C%BA/">vulnhub-DC3靶场</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/09/13/vulnhub%E6%89%93%E9%9D%B6%E9%9B%86%E5%90%88/">Vulnhub打靶集合</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/09/11/laravel-debug-mode-rce%EF%BC%88cve-2021-3129%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">Laravel Debug mode RCE（CVE-2021-3129）漏洞复现</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/25/selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">selenium自动化工具的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/13/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E6%94%BB%E5%85%8B%E7%AC%94%E8%AE%B0%E5%9B%9B/">红日靶场攻克笔记四</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/20/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">电子取证入门指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/17/%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9%E7%9A%84%E5%9F%BA%E7%A1%80%E9%98%B2%E6%8A%A4/">关于个人博客站点的基础防护</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Ly's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>